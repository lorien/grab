.. _dom:

.. currentmodule:: grab.ext.lxml

====================
Работа с DOM-деревом
====================

Интерфейс к LXML библиотеке
===========================

Первое, что вам нужно усвоить, это то, что Grab предоставляет всего лишь удобный интерфейс к функциям библиотеки `lxml <http://lxml.de>`_. Крайне желательно, знать и понимать API библиотеки lxml. Grab предоставляет множество функций поиска данных в документе. Большинство этих функций представляют из себя xpath-запрос к DOM-дереву и последующую его обработку.

Далее описаны основные принципы использования lxml-расширения. Полный список методов (и их описание) вы можете посмотреть в API справочнике :ref:`extensions_lxml`.

DOM-дерево
==========

DOM-дерево доступно через аттрибут :meth:`tree <LXMLExtension.tree`::

    >>> g.go('http://vk.com')
    <grab.response.Response object at 0x1c9ae10>
    >>> g.tree
    <Element html at 1c96940>
    >>> print g.tree.xpath('//title/text()')[0]
    Welcome!
    
Вычисление DOM-дерева требует значительных ресурсов процессора, поэтому оно не вычисляется сразу после получения тела документа, а лишь только при первом вызове какого-либо xpath/css метода или обращении к аттрибуту :meth:`tree <LXMLExtension.tree`. DOM-дерево вычисляется один раз и затем кэшируется.


XPATH-методы
============

Самый часто используемый метод, это :meth:`~LXMLExtension.xpath`. В качестве аргумента он принимает xpath-выражение и возвращает найденный узел DOM-дерева. Пожалуйста, не путайте :meth:`~LXMLExtension.xpath` метод объекта Grab и `xpath` метод `lxml.html.etree.Element` объекта. Последний возвращает список элементов, в то время как `xpath` метод Grab-объекта возвращает первый найденный элемент. Если вам нужен список объектов, используйте :meth:`~LXMLExtension.xpath_list` метод. Приведу наглядный пример::

    >>> g.go('http://google.com')
    <grab.response.Response object at 0x1ae73d0>
    >>> g.xpath_list('//*[@type="submit"]')
    [<InputElement 1a35e88 name='btnG' type='submit'>, <InputElement 1c96530 name='btnI' type='submit'>]
    >>> g.xpath('//*[@type="submit"]')
    <InputElement 1a35e88 name='btnG' type='submit'>
    >>> from lxml.html import fromstring
    >>> fromstring(g.response.body).xpath('//*[@type="submit"]')
    [<InputElement 1c966d0 name='btnG' type='submit'>, <InputElement 1c96598 name='btnI' type='submit'>]    

Методом `xpath_text` вы можете извлечь текстовое содержимое из найденного DOM-элемента. Метод `xpath_number` извлекает в начале текстовое содержимое, затем ищет там число::

    >>> g.go('http://rambler.ru')
    <grab.response.Response object at 0x1c9a650>
    >>> print g.xpath_text('//td[@class="Spine"]//nobr')
    1996—2012
    >>> print g.xpath_number('//td[@class="Spine"]//nobr')
    1996

CSS-методы
==========

Благодаря модулю `cssselect <http://lxml.de/cssselect.html>`_, можно искать элементы в DOM-дереве с помощью CSS-выражений. Поддерживаются основные CSS2-селекторы, не все. Список и название методов для работы с CSS аналогичен списку методов для работы с xpath.

    >>> g.go('http://rambler.ru')
    <grab.response.Response object at 0x1c9a650>
    >>> print g.css_text('td.Spine nobr')
    1996—2012
    >>> print g.css_number('td.Spine nobr')
    1996


Структурированный разбор документа
==================================

Не редко данные в документе явно структурированы. Например, когда документ имеет набор таких блоков

    <li class="item">
        <h3>Заголовок 1</h3>
        <span>Подзаголовок</span>
        <div>
            <div class="tags">
                <span>тэг 1</span>
                <span>тэг 2</span>
                <span class="active">тэг 3</span>
                <span>тэг 4</span>
            </div>
        </div>
    </li>

явно что привязавшить через XPATH-селектор //li[@class="item"] к каждому из них, XPATH-селектор для узлов внутри каждого такого блока можно будет значительно упростить сделав его относительным. Для того чтобы не опрерировать вручную каждым узлом, есть возможность комплексно извлечь данные.

Для этого предназначен модуль `grab/tools/structured.py`.

В приведенном примере есть два явно выраженных блока расположенных друг относительно друга: `//li[@class="item"]` и `.//div[@class="tags"]`. А также, отдельные семантические единицы `./h3/text()`, `./span/text()` у блока `//li[@class="item"]` и `./span/text()` у блока `.//div[@class="tags"]`.

Каждый семантический элемент должен быть описан экземпляром класса `grab.tools.structured.Chunk`, конструктор которого первым параметром принимает относительный селектор этого элемента, а вторым, необязательным параметром, функцию, которой будет передан этот извлеченный элемент для дополнительного преобразования, в случае, когда XPATH недостаточно. Кроме того, можно указать, через параметр `one`, нужно ли брать первый попавшийся узел или этому селектору отвечает несколь узлов, которые должны быть возвращены в виде массива.

А каждый блок внутри документа, который сам содержит другие семантические элементы, либо другие блоки, следует описывать через экземпляр класса `grab.tools.structured.Structure`. Первым параметром конструктор этого класса принимает XPATH-селектор блока, далее в качестве параметров можно передать любое количество других таких блоков инстанцированных черех `Structure`, либо отдельных семантических единиц через `Chunk`.

Для доступа к функционалу структурного разбора внутри документа служит метод `grab.doc.structure`, все переданные параметры которому используются для создания экземпляра класса `grab.tools.structured.Structure`. Таким образом, нет необходимости передавать этому методу экземпляр класса для описания самого верхнего блока, а сразу описать параметры для его конструктора.

Примером описания может служить этот код:

    >>> from grab.tools.structured import Structure as x, Chunk as c
    >>> grab.doc.structure(
    ...     '//li[@class="item"]',
    ...     x(
    ...         './/div[@class="tags"]',
    ...         tags=c(
    ...             './span/text()',
    ...             one=False
    ...         )
    ...     ),
    ...     title=c('./h3/text()'),
    ...     description=c('./span/text()'),
    ... )
    [{'description': u'Подзаголовок',
      'tags': [u'тэг 1',
               u'тэг 2',
               u'тэг 3',
               u'тэг 4'],
      'title': u'Заголовок 1'}]

Результатом выборки является список словарей в которых хранятся извлеченные данные согласно описанной структуре.

Для семантических единиц ключами в таком словаре является имя параметра под которым передан экземпляр класса `grab.tools.structured.Chunk`.

Если параметр используемый при описании не является экземпляром `grab.tools.structured.Structure`, то автоматически будет произведена привести его к `grab.tools.structured.Chunk`. Таким образом, не инстанцировать класс `grab.tools.structured.Chunk` напрямую, а передать только XPATH-селектор строкой, либо массив из переменного числа параметров для конструктора
    >>> grab.doc.structure(
    ...     '//li',
    ...     title='./h3/text()',
    ...     tags=(
    ...         './/div/span/text()',# относительный селектор
    ...         unicode,             # функция которая будет примененина к каждому элементу по селектору
    ...         all,                 # функция фильтрации элементов
    ...         False                # флаг, нужно ли выбирать только первый попавший под селектор элемент
    ...     )
    ... )
    [{'tags': [u'тэг 1',
               u'тэг 2',
               u'тэг 3',
               u'тэг 4'],
      'title': u'Заголовок 1'}]


Обработка исключений
====================

Если xpath/css метод не нашёл данных, то генерируется исключение :class:`~grab.error.DataNotFound`. Класс этого ислючения унаследован от :class:`IndexError`, так что можно просто ловить IndexError на заморачиваясь на импорт `DataNotFound` исключения::

    >>> try:
    ...     g.xpath('//foobar')
    ... except IndexError:
    ...     print 'not found'
    ... 
    not found

Все xpath/css методы понимают аргумент `default`, если вы зададите его, то в случае, когда данные не были найден, вместо генерации исключения, xpath/css метод вернёт указанное значение. В качестве значения вы можете передавать даже `None`::

    >>> print g.xpath('//foobar')
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "/usr/local/lib/python2.6/dist-packages/grab/ext/lxml.py", line 134, in xpath
        raise DataNotFound('Xpath not found: %s' % path)
    grab.error.DataNotFound: Xpath not found: //foobar
    >>> print g.xpath('//foobar', default=None)
    None
    >>> print g.xpath('//foobar', default='spam')
    spam
